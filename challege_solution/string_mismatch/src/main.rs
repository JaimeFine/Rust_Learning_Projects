use ansi_term::Colour;
use std::io;

/*
>>> Original code:
fn main() -> Result<(), std::io::Error> {
    let mut color = String::new();
    io::stdin().read_line(&mut color)?;
    let color = color.trim().to_string();

    let output = match color {
        "red" => Colour::Red.paint("This is a red phrase"),
        _ => Colour::White.paint("..."),
    };

    println!("{}", output);

    Ok(())
}
*/

/*
>>> My own correction:
fn main() -> Result<(), std::io::Error> {
    let mut color = String::new();
    io::stdin().read_line(&mut color)?;
    let color = color.trim().to_string();

    let output = match color.as_str() {
        "red" => Colour::Red.paint("This is a red phrase"),
        _ => Colour::White.paint("..."),
    };

    println!("{}", output);

    Ok(())
}
*/

// Final version: note that this result was generated by AI
fn main() -> Result<(), std::io::Error> {
    let mut color_buffer = String::new(); // Original owned String buffer
    io::stdin().read_line(&mut color_buffer)?;
    
    // KEY CHANGE: `color` is now the &str result of .trim()
    let color = color_buffer.trim(); 

    // Match the &str against &str literals (the most efficient way)
    let output = match color {
        "red" => Colour::Red.paint("This is a red phrase"),
        _ => Colour::White.paint("..."),
    };
    // --snip--
}