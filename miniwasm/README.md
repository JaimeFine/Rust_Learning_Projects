# Rust WebAssembly Template

A minimal project demonstrating how to compile a Rust function to WebAssembly (Wasm) and execute it within a modern web browser, enabling near-native performance for web applications.

---

## ✨ Features

### Core Wasm Integration

- **Compilation Target**: Uses the `cdylib` crate type for building a WebAssembly binary (`.wasm`).
- **Interoperability**: Leverages `wasm-bindgen` to create JavaScript "glue" code, allowing seamless calling of Rust functions (`greet`) from JavaScript and vice versa.
- **Thread-safe Communication**: Rust's strict safety guarantees are preserved in the compiled Wasm module.
- **Module-Based Loading**: The Wasm binary and JS wrapper are imported using standard ES Modules:

```js
import init, { greet } from './pkg/miniwasm.js';
```

### Web Frontend

- A single `index.html` file handles all HTML structure, CSS (via Tailwind), and JavaScript orchestration.
- A responsive interface for testing the Wasm function.

---

## 📂 Project Structure

```
.
├── src
│   └── lib.rs             # The exposed Rust function using #[wasm_bindgen]
├── Cargo.toml             # Defines project, dependencies, and Wasm library type
└── index.html             # The web frontend that loads the Wasm module
```

---

## 🚀 Getting Started

### Prerequisites

- **Rust (latest stable)**: Ensure you have the Rust toolchain installed.
- **wasm-pack**: The toolchain for building Rust to WebAssembly.

```bash
cargo install wasm-pack
```

- **HTTP Server**: Needed to serve the files locally (browsers require Wasm files to be loaded via HTTP, not `file:///`).

```bash
npm install -g http-server
```

### Build and Run

1. **Initialize Project** (if not already done):

```bash
cargo new --lib miniwasm
cd miniwasm
# Add wasm-bindgen to Cargo.toml
```

2. **Compile Rust to Wasm**:

```bash
wasm-pack build --target web
```

3. **Start the Server** (from the project root, where `index.html` and `pkg/` are):

```bash
http-server .
```

The server listens on `127.0.0.1:8080`.

---

## 🌐 Usage

Open your web browser and navigate to:

[http://127.0.0.1:8080/index.html](http://127.0.0.1:8080/index.html)

### Interaction Flow

1. The browser executes the JavaScript in `index.html`.
2. The JS imports and initializes the Wasm module (`init()` from `miniwasm.js`).
3. When the user clicks the "Run Rust greet() Function" button, the JS calls the exported Wasm function: `greet("User Name")`.
4. The Rust code executes its logic:  
   `format!("Hello, {}...", name)`
5. The resulting string is passed back to JavaScript and displayed on the page.

---

## 🦀 Wasm Core Concept

The magic happens due to the `#[wasm_bindgen]` macro in `src/lib.rs`:

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn greet(name: &str) -> String {
    // ...
}
```

- `#[wasm_bindgen]`: This macro instructs the Rust compiler to generate the necessary bindings so that JavaScript knows how to call the function (`greet`) and how to safely handle the complex types (like Rust's `&str` and `String`) passed between the two language environments.

### The JS Glue

The generated `miniwasm.js` file handles the complex task of memory mapping, translating JavaScript types into Wasm types, and making the final function call, abstracting away the low-level details of the Wasm binary.

---

> Note that this README.md was generated by AI, might contain some errors!